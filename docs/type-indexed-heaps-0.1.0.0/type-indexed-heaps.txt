-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Heaps with verified and unverified versions.
--   
--   This library provides implementations of five different heaps
--   (binomial, pairing, skew, leftist, and Braun), each in two flavours:
--   one verified, and one not.
--   
--   At the moment, only structural invariants are maintained.
--   
--   <h1>Comparisons of verified and unverified heaps</h1>
--   
--   Both versions of each heap are provided for comparison: for instance,
--   compare the standard leftist heap (in <a>Data.Heap.Leftist</a>):
--   
--   <pre>
--   data Leftist a
--     = Leaf
--     | Node !Int
--           a
--           (Leftist a)
--           (Leftist a)
--   </pre>
--   
--   To its size-indexed counterpart (in <a>Data.Heap.Indexed.Leftist</a>):
--   
--   <pre>
--   data Leftist n a where
--           Leaf :: Leftist 0 a
--           Node :: !(The Nat (n + m + 1))
--                -&gt; a
--                -&gt; Leftist n a
--                -&gt; Leftist m a
--                -&gt; !(m &lt;= n)
--                -&gt; Leftist (n + m + 1) a
--   </pre>
--   
--   The invariant here (that the size of the left heap must always be less
--   than that of the right) is encoded in the proof <tt>m <a>&lt;=</a>
--   n</tt>.
--   
--   With that in mind, compare the unverified and verified implementatons
--   of <tt>merge</tt>:
--   
--   <pre>
--   merge Leaf h2 = h2
--   merge h1 Leaf = h1
--   merge h1@(Node w1 p1 l1 r1) h2@(Node w2 p2 l2 r2)
--     | p1 &lt; p2 =
--         if ll &lt;= lr
--             then Node (w1 + w2) p1 l1 (merge r1 h2)
--             else Node (w1 + w2) p1 (merge r1 h2) l1
--     | otherwise =
--         if rl &lt;= rr
--             then Node (w1 + w2) p2 l2 (merge r2 h1)
--             else Node (w1 + w2) p2 (merge r2 h1) l2
--     where
--       ll = rank r1 + w2
--       lr = rank l1
--       rl = rank r2 + w1
--       rr = rank l2
--   </pre>
--   
--   Verified:
--   
--   <pre>
--   merge Leaf h2 = h2
--   merge h1 Leaf = h1
--   merge h1@(Node w1 p1 l1 r1 _) h2@(Node w2 p2 l2 r2 _)
--     | p1 &lt; p2 =
--         if ll &lt;=. lr
--           then Node (w1 +. w2) p1 l1 (merge r1 h2)
--           else Node (w1 +. w2) p1 (merge r1 h2) l1 . totalOrder ll lr
--     | otherwise =
--         if rl &lt;=. rr
--             then Node (w1 +. w2) p2 l2 (merge r2 h1)
--             else Node (w1 +. w2) p2 (merge r2 h1) l2 . totalOrder rl rr
--     where
--       ll = rank r1 +. w2
--       lr = rank l1
--       rl = rank r2 +. w1
--       rr = rank l2
--   </pre>
--   
--   <h1>Using type families and typechecker plugins to encode the
--   invariants</h1>
--   
--   The similarity is accomplished through overloading, and some handy
--   functions. For instance, the second if-then-else works on boolean
--   <i>singletons</i>, and the <tt>&lt;=.</tt> function provides a proof
--   of order along with its answer. The actual arithmetic is carried out
--   at runtime on normal integers, rather than Peano numerals. These
--   tricks are explained in more detail <a>TypeLevel.Singletons</a> and
--   <a>TypeLevel.Bool</a>.
--   
--   A typechecker plugin does most of the heavy lifting, although there
--   are some (small) manual proofs.
--   
--   <h1>Uses of verified heaps</h1>
--   
--   The main interesting use of these sturctures is total traversable
--   sorting (<a>sort-traversable</a>). An implementation of this is
--   provided in <a>Data.Traversable.Parts</a>. I'm interested in finding
--   out other uses for these kinds of structures.
@package type-indexed-heaps
@version 0.1.0.0


-- | Provides singletons and general type-level utilities. singletons are
--   value-level representations of types.
--   
--   <a>Eisenberg, Richard A., and Stephanie Weirich. “Dependently Typed
--   Programming with Singletons.” In Proceedings of the 2012 Haskell
--   Symposium, 117–130. Haskell ’12. New York, NY, USA: ACM, 2012.
--   doi:10.1145/2364506.2364522.</a>
module TypeLevel.Singletons

-- | A data family for singletons. The cute name allows code like this:
--   
--   <pre>
--   addZeroZero :: The Nat n -&gt; n + 0 :~: n
--   </pre>

-- | Class for singletons which can be generated.
class KnownSing (x :: k)
sing :: KnownSing x => The k x

-- | Multiply two numbers, on both the value and type level.
(*.) :: The Nat n -> The Nat m -> The Nat (n * m)
infixl 7 *.

-- | Add two numbers, on both the value and type level.
(+.) :: The Nat n -> The Nat m -> The Nat (n + m)
infixl 6 +.

-- | Raise a number to a power, on the type-level and value-level.
(^.) :: The Nat n -> The Nat m -> The Nat (n ^ m)
infixr 8 ^.

-- | Test order between two numbers, and provide a proof of that order with
--   the result.
(<=.) :: The Nat n -> The Nat m -> The Bool (n <=? m)
infix 4 <=.

-- | A proof of a total order on the naturals.
totalOrder :: p n -> q m -> (n <=? m) :~: False -> (m <=? n) :~: True

-- | A proof that x is less than or equal to y.
type (<=) x y = (x <=? y) :~: True

-- | Addition of type-level naturals.

-- | Multiplication of type-level naturals.

-- | Exponentiation of type-level naturals.

-- | (Kind) This is the kind of type-level natural numbers.
data Nat :: *
instance TypeLevel.Singletons.KnownSing 'GHC.Types.True
instance TypeLevel.Singletons.KnownSing 'GHC.Types.False
instance TypeLevel.Singletons.KnownSing '[]
instance forall a (xs :: [a]) (x :: a). (TypeLevel.Singletons.KnownSing xs, TypeLevel.Singletons.KnownSing x) => TypeLevel.Singletons.KnownSing (x : xs)
instance GHC.TypeLits.KnownNat n => TypeLevel.Singletons.KnownSing n


-- | Type-level Peano arithmetic.
module TypeLevel.Nat

-- | Peano numbers.
data Nat
Z :: Nat
S :: Nat -> Nat

-- | Singleton for type-level Peano numbers.

-- | Add two type-level numbers.


-- | Some proofs on type-level Peano numbers.
module TypeLevel.Nat.Proofs

-- | Addition is associative.
plusAssoc :: The Nat x -> p y -> q z -> ((x + y) + z) :~: (x + (y + z))

-- | Zero is the identity of addition.
addZeroZero :: The Nat x -> (x + Z) :~: x


-- | Rebinable syntax helper.
module TypeLevel.Bool

-- | For use with <tt>-XRebindableSyntax</tt>. This function can be used to
--   make Haskell look reasonably dependent:
--   
--   <pre>
--   depHask :: <a>The</a> <a>Bool</a> x -&gt; <a>IfThenElse</a> x <a>Int</a> <a>String</a>
--   depHask cond =
--       if cond
--           then \<a>Refl</a> -&gt; 1
--           else \<a>Refl</a> -&gt; "abc"
--   </pre>
ifThenElse :: The Bool c -> (c :~: True -> a) -> (c :~: False -> a) -> a

-- | Type-level if then else.


-- | Functions for creating rose trees (from <a>Data.Tree</a>) of a
--   specified size.
module Data.Tree.Replicate

-- | <tt><a>replicateA</a> n x</tt> replicates the action <tt>x</tt>
--   <tt>n</tt> times.
replicateA :: Applicative f => Int -> f a -> f (Tree a)

-- | <tt><a>replicateTree</a> n a</tt> creates a tree of size <tt>n</tt>
--   filled with <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putStr (drawTree (replicateTree 4 "."))
--   .
--   |
--   +- .
--   |
--   `- .
--      |
--      `- .
--   </pre>
--   
--   <pre>
--   n &gt; 0 ==&gt; length (replicateTree n x) == n
--   </pre>
replicateTree :: Int -> a -> Tree a


-- | Classes for common functions between the heaps.
module Data.Heap.Indexed.Class

-- | A classed for indexed priority queues. Equivalent to <a>Queue</a>
--   except the queues are indexed by their sizes.
class IndexedQueue h a where singleton = flip insert empty

-- | The empty queue
empty :: IndexedQueue h a => h 0 a

-- | Return the minimal element, and the rest of the queue.
minView :: IndexedQueue h a => h (1 + n) a -> (a, h n a)

-- | A queue with one element.
singleton :: IndexedQueue h a => a -> h 1 a

-- | Add an element to the queue.
insert :: IndexedQueue h a => a -> h n a -> h (1 + n) a

-- | Pattern match on the queue, and provide a proof that it is/isn't empty
--   to the caller.
minViewMay :: IndexedQueue h a => h n a -> (n ~ 0 => b) -> (forall m. (1 + m) ~ n => a -> h m a -> b) -> b

-- | Queues which can be merged. Conforming members should form a monoid
--   under <a>merge</a> and <a>empty</a>.
class IndexedQueue h a => MeldableIndexedQueue h a

-- | Merge two heaps. This operation is associative, and has the identity
--   of <a>empty</a>.
--   
--   <pre>
--   <a>merge</a> x (<a>merge</a> y z) = <a>merge</a> (<a>merge</a> x y) z
--   </pre>
--   
--   <pre>
--   <a>merge</a> x <a>empty</a> = <a>merge</a> <a>empty</a> x = x
--   </pre>
merge :: MeldableIndexedQueue h a => h n a -> h m a -> h (n + m) a


-- | Statically verified, type-indexed, weight-biased leftist heaps.
module Data.Heap.Indexed.Leftist

-- | A size-indexed weight-biased leftist heap. Somewhat based on the
--   implementation from <a>here</a>.
--   
--   Type-level natural numbers are used to maintain the invariants in the
--   size of the structure, but these are backed by <a>Natural</a> at
--   runtime, maintaining some efficiency.
--   
--   For instance, the <a>&lt;=.</a> function is used, which compares two
--   numbers (runtime integers), but provides a boolean singleton as its
--   result: when matched on, this provides a <i>type-level-proof</i> of
--   the ordering.
data Leftist n a
[Leaf] :: Leftist 0 a
[Node] :: !(The Nat ((n + m) + 1)) -> a -> Leftist n a -> Leftist m a -> !(m <= n) -> Leftist ((n + m) + 1) a
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.IndexedQueue Data.Heap.Indexed.Leftist.Leftist a
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.MeldableIndexedQueue Data.Heap.Indexed.Leftist.Leftist a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Indexed.Leftist.Leftist n a)


-- | Size-indexed pairing heaps.
module Data.Heap.Indexed.Pairing

-- | A simple size-indexed pairing heap. In practice, this heap seems to
--   have the best performance.
--   
--   Inspired by the implementation <a>here</a>, but uses type-level
--   literals, rather than type-level Peano numbers.
data Pairing n a
[E] :: Pairing 0 a
[T] :: a -> HVec n a -> Pairing (1 + n) a

-- | A size-indexed vector of pairing heaps.
data HVec n a
[HNil] :: HVec 0 a
[HCons] :: Pairing m a -> HVec n a -> HVec (m + n) a
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.IndexedQueue Data.Heap.Indexed.Pairing.Pairing a
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.MeldableIndexedQueue Data.Heap.Indexed.Pairing.Pairing a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Indexed.Pairing.Pairing n a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Indexed.Pairing.HVec n a)


-- | Size-indexed skew heaps.
module Data.Heap.Indexed.Skew

-- | A size-indexed skew heap.
data Skew n a
[Empty] :: Skew 0 a
[Node] :: a -> Skew n a -> Skew m a -> Skew ((1 + n) + m) a
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.IndexedQueue Data.Heap.Indexed.Skew.Skew a
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.MeldableIndexedQueue Data.Heap.Indexed.Skew.Skew a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Indexed.Skew.Skew n a)


-- | Sort any traversable. Idea from <a>here</a>, but parameterized over
--   the heap type.
--   
--   Parts can be thought of as a safe version of <tt>unsafePartsOf</tt>
--   from lens.
module Data.Traversable.Parts

-- | A queue with a certain number of elements, and a function which
--   extracts exactly that many elements from a larger queue. You can
--   transform the queue (i.e., reversing, etc.) before running the
--   function, effectively transforming the contents of a traversable
--   safely. If the underlying queue is a priority queue, then inserting
--   elements will sort them as you go.
data Parts f g a b r
[Parts] :: (forall n. g (m + n) b -> (g n b, r)) -> !(f m a) -> Parts f g a b r

-- | Lift a value into the running queue.
liftParts :: (IndexedQueue g a, IndexedQueue f x) => x -> Parts f g x a a

-- | Enqueue every element of a traversable into a queue, and then dequeue
--   them back into the same traversable. This is useful if, for instance,
--   the queue is a priority queue: then this function will perform a sort.
--   If the queue is first-in last-out, this function will perform a
--   reversal.
queueTraversable :: (MeldableIndexedQueue f a, Traversable t) => p f -> t a -> t a

-- | Run the built-up function on the stored queue.
runParts :: forall a b f. Parts f f b b a -> a

-- | Queues a traversal.
queueTraversal :: (IndexedQueue f b, IndexedQueue f a) => ((a -> Parts f f a b b) -> t -> Parts f f a a t) -> t -> t

-- | Perform a length-preserving transformation on the stored queue, and
--   run the built-up function on the transformed version.
runPartsWith :: forall a b c f g. (forall n. f n a -> g n b) -> Parts f g a b c -> c

-- | Perform an arbitrary length-preserving transformation on a lens-style
--   traversal.
transformTraversal :: (IndexedQueue g b, IndexedQueue f a) => (forall n. f n a -> g n b) -> ((a -> Parts f g a b b) -> t -> Parts f g a b t) -> t -> t

-- | Apply a function which transforms a queue without changing its size to
--   an arbitrary traversable.
transformTraversable :: (MeldableIndexedQueue f a, IndexedQueue g b, Traversable t) => (forall n. f n a -> g n b) -> t a -> t b
instance GHC.Base.Functor (Data.Traversable.Parts.Parts f g a b)
instance (Data.Heap.Indexed.Class.IndexedQueue f x, Data.Heap.Indexed.Class.MeldableIndexedQueue f x) => GHC.Base.Applicative (Data.Traversable.Parts.Parts f g x y)


-- | This module exists to showcase some uses for indexed non-priority
--   queues.
module Data.List.Indexed

-- | A simple length-indexed list.
data List n a
[Nil] :: List 0 a
[:-] :: a -> List n a -> List (1 + n) a

-- | A list with efficient concatenation.
newtype DiffList n a
DiffList :: (forall m. List m a -> List (n + m) a) -> DiffList n a
[runDiffList] :: DiffList n a -> forall m. List m a -> List (n + m) a

-- | Performs merging in reverse order.

-- | Efficiently reverse any traversable, safely and totally.
reverseTraversable :: Traversable t => t a -> t a
instance Data.Heap.Indexed.Class.IndexedQueue Data.List.Indexed.List a
instance Data.Heap.Indexed.Class.MeldableIndexedQueue Data.List.Indexed.List a
instance Data.Heap.Indexed.Class.IndexedQueue Data.List.Indexed.DiffList a
instance Data.Heap.Indexed.Class.MeldableIndexedQueue Data.List.Indexed.DiffList a


-- | Type-indexed Braun heaps.
module Data.Heap.Indexed.Braun

-- | A Braun heap. Somewhat based on <a>this implementation</a>, but with a
--   different strategy for maintaining invariants.
--   
--   A braun tree is one where every left branch has at most one more
--   element than the right branch.
data Braun n a
[Leaf] :: Braun 0 a
[Node] :: !(Offset n m) -> a -> Braun n a -> Braun m a -> Braun ((n + m) + 1) a

-- | The "singleton" for whether or not the left branch is larger than the
--   right.
data Offset n m
[Even] :: Offset n n
[Lean] :: Offset (1 + n) n
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.IndexedQueue Data.Heap.Indexed.Braun.Braun a
instance Control.DeepSeq.NFData (Data.Heap.Indexed.Braun.Offset n m)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Indexed.Braun.Braun n a)


-- | Size-indexed binomial heaps.
module Data.Heap.Indexed.Binomial

-- | A size-indexed binomial tree.
data Tree n a
Root :: a -> (Node n a) -> Tree n a

-- | A binomial tree, indexed by its size.
data Node :: Nat -> * -> *
[NilN] :: Node 0 a
[:<] :: {-# UNPACK #-} !(Tree n a) -> Node n a -> Node (1 + n) a

-- | A size-indexed binomial heap.
--   
--   The implementation is similar to:
--   
--   <ul>
--   <li><a>Hinze, Ralf. “Functional Pearls: Explaining Binomial Heaps.”
--   Journal of Functional Programming 9, no. 1 (January 1999): 93–104.
--   doi:10.1017/S0956796899003317.</a></li>
--   <li><a>Wasserman, Louis. “Playing with Priority Queues.” The
--   Monad.Reader, May 12, 2010.</a></li>
--   </ul>
--   
--   However invariants are more aggressively maintained, using a
--   typechecker plugin. It is a list of binomial trees, equivalent to a
--   binary number (stored least-significant-bit first).
data Binomial :: Nat -> Nat -> * -> *
[Nil] :: Binomial n 0 a
[:-] :: {-# UNPACK #-} !(Tree z a) -> Binomial (1 + z) xs a -> Binomial z ((1 + xs) + xs) a
[Skip] :: Binomial (1 + z) (1 + xs) a -> Binomial z ((2 + xs) + xs) a
instance Data.Foldable.Foldable (Data.Heap.Indexed.Binomial.Binomial rk n)
instance GHC.Base.Functor (Data.Heap.Indexed.Binomial.Binomial rk n)
instance Data.Traversable.Traversable (Data.Heap.Indexed.Binomial.Binomial rk n)
instance Data.Foldable.Foldable (Data.Heap.Indexed.Binomial.Tree rk)
instance GHC.Base.Functor (Data.Heap.Indexed.Binomial.Tree rk)
instance Data.Traversable.Traversable (Data.Heap.Indexed.Binomial.Tree rk)
instance GHC.Generics.Generic (Data.Heap.Indexed.Binomial.Tree n a)
instance GHC.Generics.Generic1 (Data.Heap.Indexed.Binomial.Tree n)
instance Data.Foldable.Foldable (Data.Heap.Indexed.Binomial.Node rk)
instance GHC.Base.Functor (Data.Heap.Indexed.Binomial.Node rk)
instance Data.Traversable.Traversable (Data.Heap.Indexed.Binomial.Node rk)
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.IndexedQueue (Data.Heap.Indexed.Binomial.Binomial 0) a
instance GHC.Classes.Ord a => Data.Heap.Indexed.Class.MeldableIndexedQueue (Data.Heap.Indexed.Binomial.Binomial 0) a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Indexed.Binomial.Binomial rk n a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Indexed.Binomial.Tree rk a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Indexed.Binomial.Node rk a)


-- | Classes for the various heaps, mainly to avoid name clashing.
module Data.Heap.Class

-- | A class for queues. Conforming members can have their own definition
--   of order on their contents. (i.e., <a>Ord</a> is not required)
class Queue h a where singleton = flip insert empty toList = unfoldr minView fromList = foldr insert empty heapSort (_ :: p h) = toList . (fromList :: [a] -> h a)

-- | Return the first element, and the remaining elements, or
--   <a>Nothing</a> if the queue is empty. For most queues, this will be
--   the minimal element
minView :: Queue h a => h a -> Maybe (a, h a)

-- | Insert an element into the queue.
insert :: Queue h a => a -> h a -> h a

-- | The empty queue.
empty :: Queue h a => h a

-- | A queue with one element.
singleton :: Queue h a => a -> h a

-- | Return a list of the contents of the queue, in order, from smallest to
--   largest.
toList :: Queue h a => h a -> [a]

-- | Create a heap from a list.
fromList :: Queue h a => [a] -> h a

-- | Perform heap sort on a list of items.
heapSort :: Queue h a => p h -> [a] -> [a]

-- | A class for meldable queues. Conforming members should form a monoid
--   under <a>merge</a> and <a>empty</a>.
class Queue h a => MeldableQueue h a where fromFoldable = runQueueWrapper #. foldMap (QueueWrapper #. singleton)

-- | Merge two heaps. This operation is associative, and has the identity
--   of <a>empty</a>.
--   
--   <pre>
--   <a>merge</a> x (<a>merge</a> y z) = <a>merge</a> (<a>merge</a> x y) z
--   </pre>
--   
--   <pre>
--   <a>merge</a> x <a>empty</a> = <a>merge</a> <a>empty</a> x = x
--   </pre>
merge :: MeldableQueue h a => h a -> h a -> h a

-- | Create a heap from a <a>Foldable</a> container. This operation is
--   provided to allow the use of <a>foldMap</a>, which may be
--   asymptotically more efficient. The default definition uses
--   <a>foldMap</a>.
fromFoldable :: (MeldableQueue h a, Foldable f) => f a -> h a

-- | A default definition for <a>showsPrec</a>.
showsPrecQueue :: (Queue h a, Show a) => Int -> h a -> ShowS

-- | A default definition for <a>readsPrec</a>.
readPrecQueue :: (Read a, Queue h a) => Int -> ReadS (h a)

-- | A default definition of <a>==</a>.
eqQueue :: (Eq a, Queue h a) => h a -> h a -> Bool

-- | A default definition of <a>compare</a>.
cmpQueue :: (Ord a, Queue h a) => h a -> h a -> Ordering
instance Data.Heap.Class.MeldableQueue h a => GHC.Base.Monoid (Data.Heap.Class.QueueWrapper h a)
instance GHC.Classes.Ord a => Data.Heap.Class.Queue Data.Set.Base.Set a
instance GHC.Classes.Ord a => Data.Heap.Class.MeldableQueue Data.Set.Base.Set a
instance Data.Heap.Class.Queue [] a
instance Data.Heap.Class.MeldableQueue [] a


-- | Erase the size parameter on a size-indexed heap, using existentials.
module Data.Heap.Indexed.Erased

-- | This type contains a size-indexed heap, however the size index is
--   hidden. This allows it to act like a standard heap, while maintaining
--   the proven invariants of the size-indexed version.
data ErasedSize f a
ErasedSize :: f n a -> ErasedSize f a
[runErasedSize] :: ErasedSize f a -> f n a
instance Data.Heap.Indexed.Class.IndexedQueue h a => Data.Heap.Class.Queue (Data.Heap.Indexed.Erased.ErasedSize h) a
instance Data.Heap.Indexed.Class.MeldableIndexedQueue h a => Data.Heap.Class.MeldableQueue (Data.Heap.Indexed.Erased.ErasedSize h) a


-- | Leftist heaps.
module Data.Heap.Leftist

-- | A simple, unchecked, weight-biased leftist heap. Based on
--   implementation from <a>here</a>.
data Leftist a
Leaf :: Leftist a
Node :: {-# UNPACK #-} !Int -> a -> (Leftist a) -> (Leftist a) -> Leftist a

-- | A zygomorphism over the heap. Useful for checking shape properties.
zygoLeftist :: b1 -> (Int -> a -> b1 -> b1 -> b1) -> b -> (Int -> a -> b1 -> b -> b1 -> b -> b) -> Leftist a -> b
instance GHC.Generics.Generic1 Data.Heap.Leftist.Leftist
instance GHC.Generics.Generic (Data.Heap.Leftist.Leftist a)
instance Data.Data.Data a => Data.Data.Data (Data.Heap.Leftist.Leftist a)
instance Data.Traversable.Traversable Data.Heap.Leftist.Leftist
instance Data.Foldable.Foldable Data.Heap.Leftist.Leftist
instance GHC.Base.Functor Data.Heap.Leftist.Leftist
instance GHC.Classes.Ord a => Data.Heap.Class.Queue Data.Heap.Leftist.Leftist a
instance GHC.Classes.Ord a => Data.Heap.Class.MeldableQueue Data.Heap.Leftist.Leftist a
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Heap.Leftist.Leftist a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Leftist.Leftist a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (Data.Heap.Leftist.Leftist a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Heap.Leftist.Leftist a)
instance (GHC.Show.Show a, GHC.Classes.Ord a) => GHC.Show.Show (Data.Heap.Leftist.Leftist a)
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (Data.Heap.Leftist.Leftist a)


-- | Pairing heaps.
module Data.Heap.Pairing

-- | A simple, unchecked pairing heap.
data Pairing a
E :: Pairing a
T :: a -> [Pairing a] -> Pairing a
instance GHC.Generics.Generic1 Data.Heap.Pairing.Pairing
instance GHC.Generics.Generic (Data.Heap.Pairing.Pairing a)
instance Data.Data.Data a => Data.Data.Data (Data.Heap.Pairing.Pairing a)
instance Data.Traversable.Traversable Data.Heap.Pairing.Pairing
instance Data.Foldable.Foldable Data.Heap.Pairing.Pairing
instance GHC.Base.Functor Data.Heap.Pairing.Pairing
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Heap.Pairing.Pairing a)
instance GHC.Classes.Ord a => Data.Heap.Class.Queue Data.Heap.Pairing.Pairing a
instance GHC.Classes.Ord a => Data.Heap.Class.MeldableQueue Data.Heap.Pairing.Pairing a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Pairing.Pairing a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (Data.Heap.Pairing.Pairing a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Heap.Pairing.Pairing a)
instance (GHC.Show.Show a, GHC.Classes.Ord a) => GHC.Show.Show (Data.Heap.Pairing.Pairing a)
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (Data.Heap.Pairing.Pairing a)


-- | Provides a wrapper for queues, allowing them to conform to
--   <a>Foldable</a>.
module Data.Heap.WithDict

-- | This stores the dictionary of methods for the priority queue of
--   <tt>f</tt>, allowing the entire type to conform to <a>Foldable</a>.
data WithDict f a
[WithDict] :: Queue f a => f a -> WithDict f a
instance (Data.Data.Data a, Data.Data.Data (f a), Data.Typeable.Internal.Typeable f, Data.Heap.Class.Queue f a) => Data.Data.Data (Data.Heap.WithDict.WithDict f a)
instance Data.Heap.Class.Queue f a => Data.Heap.Class.Queue (Data.Heap.WithDict.WithDict f) a
instance Data.Heap.Class.MeldableQueue f a => Data.Heap.Class.MeldableQueue (Data.Heap.WithDict.WithDict f) a
instance Data.Foldable.Foldable (Data.Heap.WithDict.WithDict f)
instance Control.DeepSeq.NFData (f a) => Control.DeepSeq.NFData (Data.Heap.WithDict.WithDict f a)
instance (GHC.Classes.Eq a, Data.Heap.Class.Queue f a) => GHC.Classes.Eq (Data.Heap.WithDict.WithDict f a)
instance (GHC.Classes.Ord a, Data.Heap.Class.Queue f a) => GHC.Classes.Ord (Data.Heap.WithDict.WithDict f a)
instance (GHC.Show.Show a, Data.Heap.Class.Queue f a) => GHC.Show.Show (Data.Heap.WithDict.WithDict f a)
instance (GHC.Read.Read a, Data.Heap.Class.Queue f a) => GHC.Read.Read (Data.Heap.WithDict.WithDict f a)


-- | Simple binomial heaps, with a statically-enforced shape.
module Data.Heap.Binomial

-- | A binomial heap, where the sizes of the nodes are enforced in the
--   types.
--   
--   The implementation is based on:
--   
--   <ul>
--   <li><a>Hinze, Ralf. “Functional Pearls: Explaining Binomial Heaps.”
--   Journal of Functional Programming 9, no. 1 (January 1999): 93–104.
--   doi:10.1017/S0956796899003317.</a></li>
--   <li><a>Wasserman, Louis. “Playing with Priority Queues.” The
--   Monad.Reader, May 12, 2010.</a></li>
--   </ul>
--   
--   It is a list of binomial trees, equivalent to a binary number (stored
--   least-significant-bit first).
data Binomial rk a

-- | The empty heap
Nil :: Binomial rk a

-- | Skip a child tree (equivalent to a zero in the binary representation
--   of the data structure).
Skip :: (Binomial (S rk) a) -> Binomial rk a

-- | A child tree. Equivalent to a one in the binary representation.
(:-) :: {-# UNPACK #-} !(Tree rk a) -> (Binomial (S rk) a) -> Binomial rk a

-- | A list of binomial trees, indexed by their sizes in ascending order.
data Node n a
[NilN] :: Node Z a
[:<] :: {-# UNPACK #-} !(Tree n a) -> Node n a -> Node (S n) a

-- | A rose tree, where the children are indexed.
data Tree rk a
Root :: a -> (Node rk a) -> Tree rk a
instance Data.Foldable.Foldable (Data.Heap.Binomial.Binomial rk)
instance GHC.Base.Functor (Data.Heap.Binomial.Binomial rk)
instance Data.Traversable.Traversable (Data.Heap.Binomial.Binomial rk)
instance GHC.Generics.Generic (Data.Heap.Binomial.Binomial n a)
instance GHC.Generics.Generic1 (Data.Heap.Binomial.Binomial n)
instance Data.Foldable.Foldable (Data.Heap.Binomial.Tree rk)
instance GHC.Base.Functor (Data.Heap.Binomial.Tree rk)
instance Data.Traversable.Traversable (Data.Heap.Binomial.Tree rk)
instance GHC.Generics.Generic (Data.Heap.Binomial.Tree n a)
instance GHC.Generics.Generic1 (Data.Heap.Binomial.Tree n)
instance Data.Foldable.Foldable (Data.Heap.Binomial.Node rk)
instance GHC.Base.Functor (Data.Heap.Binomial.Node rk)
instance Data.Traversable.Traversable (Data.Heap.Binomial.Node rk)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Heap.Binomial.Binomial rk a)
instance GHC.Classes.Ord a => Data.Heap.Class.Queue (Data.Heap.Binomial.Binomial 'TypeLevel.Nat.Z) a
instance GHC.Classes.Ord a => Data.Heap.Class.MeldableQueue (Data.Heap.Binomial.Binomial 'TypeLevel.Nat.Z) a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Binomial.Binomial rk a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Binomial.Tree rk a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Binomial.Node rk a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (Data.Heap.Binomial.Binomial 'TypeLevel.Nat.Z a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Heap.Binomial.Binomial 'TypeLevel.Nat.Z a)
instance (GHC.Show.Show a, GHC.Classes.Ord a) => GHC.Show.Show (Data.Heap.Binomial.Binomial 'TypeLevel.Nat.Z a)
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (Data.Heap.Binomial.Binomial 'TypeLevel.Nat.Z a)


-- | A simple, generic binary tree and some operations. Used in some of the
--   heaps.
module Data.BinaryTree

-- | A simple binary tree for use in some of the heaps.
data Tree a
Leaf :: Tree a
Node :: a -> (Tree a) -> (Tree a) -> Tree a

-- | Fold over a tree.
foldTree :: b -> (a -> b -> b -> b) -> Tree a -> b

-- | Check to see if this tree maintains the <a>heap property</a>.
isHeap :: Ord a => Tree a -> Bool

-- | Unfold a tree from a seed.
unfoldTree :: (b -> Maybe (a, b, b)) -> b -> Tree a

-- | <tt><a>replicateTree</a> n a</tt> creates a tree of size <tt>n</tt>
--   filled <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; replicateTree 4 ()
--   Node () (Node () (Node () Leaf Leaf) Leaf) (Node () Leaf Leaf)
--   </pre>
--   
--   <pre>
--   n &gt;= 0 ==&gt; length (replicateTree n x) == n
--   </pre>
replicateTree :: Int -> a -> Tree a

-- | <tt><a>replicateA</a> n a</tt> replicates the action <tt>a</tt>
--   <tt>n</tt> times.
replicateA :: Applicative f => Int -> f a -> f (Tree a)

-- | Construct a tree from a list, putting each even-positioned element to
--   the left.
treeFromList :: [a] -> Tree a

-- | A zygomorphism over a tree. Used if you want perform two folds over a
--   tree in one pass.
--   
--   As an example, checking if a tree is balanced can be performed like
--   this using explicit recursion:
--   
--   <pre>
--   isBalanced :: <a>Tree</a> a -&gt; Bool
--   isBalanced <a>Leaf</a> = True
--   isBalanced (<a>Node</a> _ l r)
--     = <a>length</a> l == <a>length</a> r &amp;&amp; isBalanced l &amp;&amp; isBalanced r
--   </pre>
--   
--   However, this algorithm performs several extra passes over the tree. A
--   more efficient version is much harder to read, however:
--   
--   <pre>
--   isBalanced :: Tree a -&gt; Bool
--   isBalanced = snd . go where
--     go <a>Leaf</a> = (0 :: Int,True)
--     go (<a>Node</a> _ l r) =
--         let (llen,lbal) = go l
--             (rlen,rbal) = go r
--         in (llen + rlen + 1, llen == rlen &amp;&amp; lbal &amp;&amp; rbal)
--   </pre>
--   
--   This same algorithm (the one pass version) can be expressed as a
--   zygomorphism:
--   
--   <pre>
--   isBalanced :: <a>Tree</a> a -&gt; Bool
--   isBalanced =
--       <a>zygoTree</a>
--           (0 :: Int)
--           (\_ x y -&gt; 1 + x + y)
--           True
--           go
--     where
--       go _ llen lbal rlen rbal = llen == rlen &amp;&amp; lbal &amp;&amp; rbal
--   </pre>
zygoTree :: b1 -> (a -> b1 -> b1 -> b1) -> b -> (a -> b1 -> b -> b1 -> b -> b) -> Tree a -> b

-- | Pretty-print a tree.
drawBinaryTree :: Show a => Tree a -> String
instance Data.Data.Data a => Data.Data.Data (Data.BinaryTree.Tree a)
instance GHC.Generics.Generic1 Data.BinaryTree.Tree
instance GHC.Generics.Generic (Data.BinaryTree.Tree a)
instance Data.Traversable.Traversable Data.BinaryTree.Tree
instance Data.Foldable.Foldable Data.BinaryTree.Tree
instance GHC.Base.Functor Data.BinaryTree.Tree
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.BinaryTree.Tree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.BinaryTree.Tree a)
instance GHC.Read.Read a => GHC.Read.Read (Data.BinaryTree.Tree a)
instance GHC.Show.Show a => GHC.Show.Show (Data.BinaryTree.Tree a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.BinaryTree.Tree a)
instance Data.Functor.Classes.Eq1 Data.BinaryTree.Tree
instance Data.Functor.Classes.Ord1 Data.BinaryTree.Tree
instance Data.Functor.Classes.Show1 Data.BinaryTree.Tree
instance Data.Functor.Classes.Read1 Data.BinaryTree.Tree
instance GHC.Base.Monoid (Data.BinaryTree.Tree a)


-- | Simple, unchecked braun heaps.
module Data.Heap.Braun

-- | A Braun heap. Based on <a>this implementation</a>.
--   
--   A braun tree is a <i>nearly balanced</i> binary tree: the left branch
--   can be either exactly the same size as the right, or one element
--   larger.
--   
--   This version is unchecked (<i>very</i> unchecked), and is provided
--   mainly for comparison to the checked version.
newtype Braun a
Braun :: Tree a -> Braun a
[runBraun] :: Braun a -> Tree a
instance Data.Traversable.Traversable Data.Heap.Braun.Braun
instance Data.Foldable.Foldable Data.Heap.Braun.Braun
instance GHC.Base.Functor Data.Heap.Braun.Braun
instance GHC.Generics.Generic1 Data.Heap.Braun.Braun
instance Data.Data.Data a => Data.Data.Data (Data.Heap.Braun.Braun a)
instance GHC.Generics.Generic (Data.Heap.Braun.Braun a)
instance GHC.Classes.Ord a => Data.Heap.Class.Queue Data.Heap.Braun.Braun a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Braun.Braun a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (Data.Heap.Braun.Braun a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Heap.Braun.Braun a)
instance (GHC.Show.Show a, GHC.Classes.Ord a) => GHC.Show.Show (Data.Heap.Braun.Braun a)
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (Data.Heap.Braun.Braun a)


-- | Skew heaps.
module Data.Heap.Skew

-- | A simple, unchecked skew heap.
newtype Skew a
Skew :: Tree a -> Skew a
[runSkew] :: Skew a -> Tree a
instance GHC.Generics.Generic1 Data.Heap.Skew.Skew
instance GHC.Generics.Generic (Data.Heap.Skew.Skew a)
instance Data.Data.Data a => Data.Data.Data (Data.Heap.Skew.Skew a)
instance Data.Traversable.Traversable Data.Heap.Skew.Skew
instance Data.Foldable.Foldable Data.Heap.Skew.Skew
instance GHC.Base.Functor Data.Heap.Skew.Skew
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Heap.Skew.Skew a)
instance GHC.Classes.Ord a => Data.Heap.Class.Queue Data.Heap.Skew.Skew a
instance GHC.Classes.Ord a => Data.Heap.Class.MeldableQueue Data.Heap.Skew.Skew a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Heap.Skew.Skew a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (Data.Heap.Skew.Skew a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Heap.Skew.Skew a)
instance (GHC.Show.Show a, GHC.Classes.Ord a) => GHC.Show.Show (Data.Heap.Skew.Skew a)
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (Data.Heap.Skew.Skew a)
