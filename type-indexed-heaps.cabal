name:                type-indexed-heaps
version:             0.1.0.0
synopsis:            Heaps with verified and unverified versions.
description:
  This library provides implementations of five different heaps
  (binomial, pairing, skew, leftist, and Braun), each in two
  flavours: one verified, and one not.
  .
  At the moment, only structural invariants are maintained.
  .
  = Comparisons of verified and unverified heaps
  Both versions of each heap are provided for comparison: for
  instance, compare the standard leftist heap (in
  "Data.Heap.Leftist"):
  .
  > data Leftist a
  >   = Leaf
  >   | Node !Int
  >         a
  >         (Leftist a)
  >         (Leftist a)
  .
  To its size-indexed counterpart (in "Data.Heap.Indexed.Leftist"):
  .
  > data Leftist n a where
  >         Leaf :: Leftist 0 a
  >         Node :: !(The Nat (n + m + 1))
  >              -> a
  >              -> Leftist n a
  >              -> Leftist m a
  >              -> !(m <= n)
  >              -> Leftist (n + m + 1) a
  .
  The invariant here (that the size of the left heap must
  always be less than that of the right) is encoded in the
  proof @m '<=' n@.
  .
  With that in mind, compare the unverified and verified
  implementatons of @merge@:
  .
  > merge Leaf h2 = h2
  > merge h1 Leaf = h1
  > merge h1@(Node w1 p1 l1 r1) h2@(Node w2 p2 l2 r2)
  >   | p1 < p2 =
  >       if ll <= lr
  >           then Node (w1 + w2) p1 l1 (merge r1 h2)
  >           else Node (w1 + w2) p1 (merge r1 h2) l1
  >   | otherwise =
  >       if rl <= rr
  >           then Node (w1 + w2) p2 l2 (merge r2 h1)
  >           else Node (w1 + w2) p2 (merge r2 h1) l2
  >   where
  >     ll = rank r1 + w2
  >     lr = rank l1
  >     rl = rank r2 + w1
  >     rr = rank l2
  .
  Verified:
  .
  > merge Leaf h2 = h2
  > merge h1 Leaf = h1
  > merge h1@(Node w1 p1 l1 r1 _) h2@(Node w2 p2 l2 r2 _)
  >   | p1 < p2 =
  >       if ll <=. lr
  >         then Node (w1 +. w2) p1 l1 (merge r1 h2)
  >         else Node (w1 +. w2) p1 (merge r1 h2) l1 . totalOrder ll lr
  >   | otherwise =
  >       if rl <=. rr
  >           then Node (w1 +. w2) p2 l2 (merge r2 h1)
  >           else Node (w1 +. w2) p2 (merge r2 h1) l2 . totalOrder rl rr
  >   where
  >     ll = rank r1 +. w2
  >     lr = rank l1
  >     rl = rank r2 +. w1
  >     rr = rank l2
  .
  = Using type families and typechecker plugins to encode the invariants
  The similarity is accomplished through overloading, and some
  handy functions. For instance, the second if-then-else works
  on boolean /singletons/, and the @<=.@ function provides a
  proof of order along with its answer. The actual arithmetic
  is carried out at runtime on normal integers, rather than
  Peano numerals. These tricks are explained in more detail
  "TypeLevel.Singletons" and "TypeLevel.Bool".
  .
  A typechecker plugin does most of the heavy lifting, although
  there are some (small) manual proofs.
  .
  = Uses of verified heaps
  The main interesting use of these sturctures is total traversable
  sorting (<https://github.com/treeowl/sort-traversable sort-traversable>).
  An implementation of this is provided in "Data.Traversable.Parts". I'm
  interested in finding out other uses for these kinds of structures.

homepage:            https://github.com/oisdk/type-indexed-heaps
license:             MIT
license-file:        LICENSE
author:              Donnacha Oisín Kidney
maintainer:          mail@doisinkidney.com
copyright:           2016 Donnacha Oisín Kidney
category:            Data Structures
build-type:          Simple
extra-source-files:  README.md
cabal-version:       >=1.10

library
  hs-source-dirs:      src
  exposed-modules:     Data.Heap.Binomial
                     , Data.Heap.Pairing
                     , Data.Heap.Skew
                     , Data.Heap.Leftist
                     , Data.Heap.Braun
                     , Data.Heap.Class
                     , Data.Heap.WithDict
                     , Data.Heap.Indexed.Pairing
                     , Data.Heap.Indexed.Binomial
                     , Data.Heap.Indexed.Skew
                     , Data.Heap.Indexed.Leftist
                     , Data.Heap.Indexed.Braun
                     , Data.Heap.Indexed.Class
                     , Data.Heap.Indexed.Erased
                     , Data.Traversable.Parts
                     , Data.List.Indexed
                     , TypeLevel.Nat
                     , Data.BinaryTree
                     , Data.Tree.Replicate
                     , TypeLevel.Singletons
                     , TypeLevel.Nat.Proofs
                     , TypeLevel.Bool
  build-depends:       base >= 4.7 && < 5
                     , ghc-typelits-natnormalise >= 0.5
                     , deepseq >= 1.4
                     , containers >= 0.5
  default-language:    Haskell2010

benchmark bench
  default-language:    Haskell2010
  type:                exitcode-stdio-1.0
  hs-source-dirs:      bench
  main-is:             bench.hs
  ghc-options:         -O2 -rtsopts -threaded

  build-depends:       base >= 4.8
                     , type-indexed-heaps
                     , criterion >= 0.6
                     , containers >= 0.5
                     , random >= 1.1
                     , pqueue >= 1.3

test-suite type-indexed-heaps-test
  type:                exitcode-stdio-1.0
  hs-source-dirs:      test
  main-is:             Spec.hs
  build-depends:       base
                     , type-indexed-heaps
                     , QuickCheck >= 2.8
                     , doctest
                     , containers >= 0.5
                     , tasty >= 0.11
                     , tasty-quickcheck >= 0.8
  ghc-options:         -threaded -rtsopts -with-rtsopts=-N
  default-language:    Haskell2010

source-repository head
  type:     git
  location: https://github.com/oisdk/type-indexed-heaps
